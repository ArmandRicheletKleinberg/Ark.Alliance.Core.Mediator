using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Ark.Alliance.Core.Mediator.Generators.Templates;

/// <summary>
/// Provides generic code generation templates that can be reused for runtime or
/// incremental scenarios.
/// </summary>
public static class GenerationTemplates
{
    /// <summary>
    /// Generates a simple IServiceCollection registration class from the
    /// provided mappings.
    /// </summary>
    public static string ServiceRegistrationTemplate(
        string namespaceName,
        IEnumerable<(string Interface, string Implementation)> registrations,
        string className = "ServiceExtensions")
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine();
        sb.AppendLine($"namespace {namespaceName};");
        sb.AppendLine();
        sb.AppendLine($"public static class {className}");
        sb.AppendLine("{");
        sb.AppendLine("    public static IServiceCollection RegisterServices(this IServiceCollection services)");
        sb.AppendLine("    {");
        foreach (var (iface, impl) in registrations)
            sb.AppendLine($"        services.AddTransient<{iface}, {impl}>();");
        sb.AppendLine("        return services;");
        sb.AppendLine("    }");
        sb.AppendLine("}");
        return sb.ToString();
    }

    /// <summary>
    /// Generates mapping extension methods between source and target types.
    /// </summary>
    public static string MappingTemplate(
        string namespaceName,
        IEnumerable<(string Source, string Target, string Expression)> mappings,
        string className = "AutoMappings")
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine();
        sb.AppendLine($"namespace {namespaceName};");
        sb.AppendLine();
        sb.AppendLine($"public static class {className}");
        sb.AppendLine("{");
        foreach (var (src, target, expr) in mappings)
        {
            var methodName = $"MapTo{target.Split('.').Last()}";
            sb.AppendLine($"    public static {target} {methodName}({src} source)");
            sb.AppendLine("    {");
            sb.AppendLine($"        return {expr};");
            sb.AppendLine("    }");
            sb.AppendLine();
        }
        sb.AppendLine("}");
        return sb.ToString();
    }

    /// <summary>
    /// Generates compiled expression helpers.
    /// </summary>
    public static string ExpressionTemplate(
        string namespaceName,
        IEnumerable<(string Type, string Name, string Expression)> expressions,
        string className = "CompiledExpressions")
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Linq.Expressions;");
        sb.AppendLine();
        sb.AppendLine($"namespace {namespaceName};");
        sb.AppendLine();
        sb.AppendLine($"public static class {className}");
        sb.AppendLine("{");
        foreach (var (type, name, expression) in expressions)
        {
            sb.AppendLine($"    private static readonly Func<{type}, object> _{name}Compiled = ({expression}).Compile();");
            sb.AppendLine();
            sb.AppendLine($"    public static object Evaluate{name}({type} obj)");
            sb.AppendLine("    {");
            sb.AppendLine($"        return _{name}Compiled(obj);");
            sb.AppendLine("    }");
            sb.AppendLine();
        }
        sb.AppendLine("}");
        return sb.ToString();
    }
}

/// <summary>
/// Builder utility for creating custom generation settings.
/// </summary>
public class GenerationConfigBuilder
{
    private readonly Dictionary<string, object> _settings = new();

    public GenerationConfigBuilder WithNamespace(string value)
    {
        _settings["Namespace"] = value;
        return this;
    }

    public GenerationConfigBuilder WithClassName(string value)
    {
        _settings["ClassName"] = value;
        return this;
    }

    public GenerationConfigBuilder WithCache(CacheMode mode, string? path = null)
    {
        _settings["CacheMode"] = mode;
        if (path != null)
            _settings["CacheFilePath"] = path;
        return this;
    }

    public GenerationConfigBuilder WithPerformanceMode(string mode)
    {
        _settings["PerformanceMode"] = mode;
        return this;
    }

    public Dictionary<string, object> Build() => new(_settings);
}
